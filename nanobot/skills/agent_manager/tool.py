import os
import subprocess
import shlex
from typing import Any, Dict, List
from pathlib import Path
from nanobot.agent.tools.base import Tool

class AgentManagerTool(Tool):
    """
    Tool for managing the lifecycle of fleet agents via standardized shell scripts.
    Implements the 'create_agent.sh' logic internally to ensure consistency.
    """
    
    FLEET_ROOT = Path("/root/.nanobot/workspace/fleet")
    
    @property
    def name(self) -> str:
        return "agent_manager"

    @property
    def description(self) -> str:
        return "Create and manage fleet agents using standardized deployment patterns."

    @property
    def parameters(self) -> dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "action": {
                    "type": "string",
                    "enum": ["create", "start", "stop", "remove", "list", "status"],
                    "description": "Action to perform."
                },
                "name": {
                    "type": "string",
                    "description": "Agent name (lowercase, e.g., 'bob')."
                },
                "telegram_token": {
                    "type": "string",
                    "description": "Telegram Bot Token (required for create)."
                },
                "model": {
                    "type": "string",
                    "description": "LLM Model (optional, e.g., 'gemini-3-pro')."
                }
            },
            "required": ["action"]
        }

    def execute(self, action: str, **kwargs) -> Any:
        method_name = f"_{action}"
        if hasattr(self, method_name):
            return getattr(self, method_name)(**kwargs)
        else:
            raise ValueError(f"Unknown action: {action}")

    def _create(self, name: str, telegram_token: str, model: str = "msp_gemini/gemini-3-pro-preview") -> str:
        """Create a new agent configuration and start script."""
        if not name or not telegram_token:
            raise ValueError("Name and Telegram Token are required for creation.")
            
        agent_id = name.lower()
        agent_dir = self.FLEET_ROOT / agent_id
        agent_dir.mkdir(parents=True, exist_ok=True)
        
        # 1. Generate Start Script (The Source of Truth)
        # Using environment variables to bypass file permission issues in Docker
        start_script_content = f"""#!/bin/bash
# Auto-generated by Sol Agent Manager
# Agent: {name}

docker rm -f {agent_id} || true

docker run -d \\
  --name {agent_id} \\
  --network deployment_hive-net \\
  --restart unless-stopped \\
  -e NANOBOT_NAME="{name.capitalize()}" \\
  -e NANOBOT_SOUL_ID="{agent_id}" \\
  -e NANOBOT_CHANNELS__TELEGRAM__ENABLED="true" \\
  -e NANOBOT_CHANNELS__TELEGRAM__TOKEN="{telegram_token}" \\
  -e NANOBOT_CHANNELS__NOSTR__ENABLED="true" \\
  -e NANOBOT_CHANNELS__NOSTR__RELAY_URL="ws://nostr-relay:8080" \\
  -e NANOBOT_PROVIDERS__CUSTOM__API_BASE="https://aigateway.mspbots.ai/v1" \\
  -e NANOBOT_PROVIDERS__CUSTOM__API_KEY="sk-j0rIB8Dx-LX5BGQvkrXY_Q" \\
  -e NANOBOT_AGENTS__DEFAULTS__MODEL="{model}" \\
  deployment-sol \\
  /bin/sh -c "nanobot gateway --port 18793"
"""
        script_path = agent_dir / "start.sh"
        with open(script_path, "w") as f:
            f.write(start_script_content)
            
        # Make executable
        os.chmod(script_path, 0o755)
        
        return f"Agent {name} created at {agent_dir}. Run 'start' action to deploy."

    def _start(self, name: str, **kwargs) -> str:
        """Start an agent using its start.sh script."""
        agent_id = name.lower()
        script_path = self.FLEET_ROOT / agent_id / "start.sh"
        
        if not script_path.exists():
            raise FileNotFoundError(f"Agent {name} not found. Create it first.")
            
        try:
            # Execute the script
            result = subprocess.run(
                [str(script_path)], 
                check=True, 
                capture_output=True, 
                text=True
            )
            return f"Agent {name} started successfully.\nContainer ID: {result.stdout.strip()}"
        except subprocess.CalledProcessError as e:
            return f"Failed to start agent {name}: {e.stderr}"

    def _stop(self, name: str, **kwargs) -> str:
        """Stop an agent container."""
        agent_id = name.lower()
        try:
            subprocess.run(["docker", "stop", agent_id], check=True)
            return f"Agent {name} stopped."
        except subprocess.CalledProcessError:
            return f"Failed to stop {name} (or not running)."

    def _remove(self, name: str, **kwargs) -> str:
        """Stop and remove an agent container."""
        agent_id = name.lower()
        try:
            # Stop first
            subprocess.run(["docker", "stop", agent_id], check=False, capture_output=True)
            # Remove (force just in case, but standard rm is fine if stopped)
            subprocess.run(["docker", "rm", agent_id], check=True, capture_output=True)
            return f"Agent {name} stopped and removed."
        except subprocess.CalledProcessError as e:
            return f"Failed to remove {name}: {e.stderr or 'Unknown error'}"

    def _list(self, **kwargs) -> str:
        """List all registered agents in the fleet directory."""
        if not self.FLEET_ROOT.exists():
            return "No agents found (fleet directory empty)."
            
        agents = []
        for d in self.FLEET_ROOT.iterdir():
            if d.is_dir() and (d / "start.sh").exists():
                agents.append(d.name)
        
        return f"Registered Agents: {', '.join(agents)}"

    def _status(self, name: str, **kwargs) -> str:
        """Check status of a specific agent container."""
        agent_id = name.lower()
        try:
            res = subprocess.run(
                ["docker", "inspect", "-f", "{{.State.Status}}", agent_id],
                capture_output=True,
                text=True
            )
            status = res.stdout.strip()
            return f"Agent {name}: {status}" if status else "Agent {name}: Not found/Offline"
        except subprocess.CalledProcessError:
            return f"Agent {name}: Not found/Offline"
